<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension=".d.ts" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ Include File="T4TS.tt.settings.t4" #><#= 
    OutputFormatter.GetOutput(GetDataToRender(), GetSettings()) #><#+ 

Settings settings = null;
Settings GetSettings()
{
    if (settings== null)
        settings = Settings.Parse(SettingsValues);

    return settings;
}

List<TypeScriptModule> GetDataToRender() {
    DTE dte = null;

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null)
        dte = serviceProvider.GetService(typeof(SDTE)) as DTE;

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (dte == null)
        throw new Exception("Can only execute through the Visual Studio host");

    var project = GetProjectContainingT4File(dte);
        
    if (project == null)
        throw new Exception("Could not find the VS project containing the T4TS file.");

    var generator = new CodeTraverser(dte.Solution, GetSettings());
    return generator.GetAllInterfaces().ToList();
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
    // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
    // Note: this is certainly hacky, but is the best I could come up with so far.
    //projectItem.Document.Saved = false;

    return projectItem.ContainingProject;
}

    public abstract class DocumentedOutputAppender<TSegment> : OutputAppender<TSegment>
        where TSegment : class, IDocumentedElement
    {
        public DocumentedOutputAppender(StringBuilder output, int baseIndentation, Settings settings)
            : base(output, baseIndentation, settings)
        {
        }

        protected void AppendDocumentation(TSegment element)
        {
            var comment = SanitizeComment(element.Comment);
            var docComment = SanitizeComment(element.DocComment);

            if (!string.IsNullOrWhiteSpace(comment))
                AppendIndentedLine(FormatComment(comment));

            if (!string.IsNullOrWhiteSpace(docComment))
                AppendIndentedLine(FormatComment(docComment));
        }

        private string FormatComment(string commentText)
        {
            return string.Concat(
                "/**  ",
                commentText.Replace(Environment.NewLine, Environment.NewLine + new string(' ', BaseIndentation) + "* "),
                " */");
        }

        private string SanitizeComment(string commentText)
        {
            if (string.IsNullOrEmpty(commentText))
                return null;

            return System.Text.RegularExpressions.Regex.Replace(commentText, @"<[^>]+>", "").Trim();
        }
    }

    public class EnumOutputAppender : DocumentedOutputAppender<TypeScriptEnum>
    {
        public EnumOutputAppender(StringBuilder output, int baseIndentation, Settings settings)
            : base(output, baseIndentation, settings)
        {
        }

        public override void AppendOutput(TypeScriptEnum tsEnum)
        {
            BeginInterface(tsEnum);

            AppendMembers(tsEnum);
            
            EndInterface();
        }
        public void AppendOutputSubEnum(TypeScriptEnum tsEnum, TypeScriptInterface owner)
        {
            BeginInterface(tsEnum, owner);

            AppendMembers(tsEnum, owner);

            EndInterface(owner);
        }

        private void AppendMembers(TypeScriptEnum tsEnum, TypeScriptInterface owner = null)
        {
            var identation = 4;
            while (owner != null)
            {
                identation += 4;
                owner = owner.Owner;
            }
            var appender = new EnumMemberOutputAppender(Output, BaseIndentation + identation, Settings);
            foreach (var member in tsEnum.Members)
                appender.AppendOutput(member);
        }

        private void BeginInterface(TypeScriptEnum tsEnum, TypeScriptInterface owner = null)
        {
            AppendIndentedLine("/** Generated from " + tsEnum.FullName + " **/");
            
            if (owner == null)
            {
                AppendDocumentation(tsEnum);
                AppendIndented("enum " + tsEnum.Name);
            }
            else
            {
                var module = owner.Name;
                var enumName = tsEnum.Name;
                var arr = tsEnum.Name.Split('.');
                if (arr.Length > 1)
                {
                    module = arr[0];
                    enumName = arr[1];
                }
                AppendIndentedLine("export module " + module + " {");

                AppendIndendation();
                AppendDocumentation(tsEnum);

                AppendIndented("enum " + enumName);

            }
            Output.AppendLine(" {");
        }

        private void EndInterface(TypeScriptInterface owner = null)
        {
            while (owner != null)
            {
                AppendIndendation();
                AppendIndentedLine("}");
                owner = owner.Owner;
            }
            AppendIndentedLine("}");
        }

    }

    public class EnumMemberOutputAppender : DocumentedOutputAppender<TypeScriptEnumMember>
    {
        public EnumMemberOutputAppender(StringBuilder output, int baseIndentation, Settings settings)
            : base(output, baseIndentation, settings)
        {
        }

        public override void AppendOutput(TypeScriptEnumMember member)
        {
            AppendDocumentation(member);
            AppendIndendation();

            Output.AppendFormat("{0} = {1}",
                member.Name,
                member.Value
            );
            
            Output.AppendLine(",");
        }
    }

    public interface IDocumentedElement
    {
        string Comment { get; }

        string DocComment { get; }
    }

    public abstract class OutputAppender<TSegment> where TSegment: class
    {
        protected StringBuilder Output { get; private set; }
        protected int BaseIndentation { get; private set; }
        protected Settings Settings { get; private set; }

        public OutputAppender(StringBuilder output, int baseIndentation, Settings settings)
        {
            if (output == null)
                throw new ArgumentNullException("output");
            
            if (settings == null)
                throw new ArgumentNullException("settings");

            this.Output = output;
            this.BaseIndentation = baseIndentation;
            this.Settings = settings;
        }

        public abstract void AppendOutput(TSegment segment);

        protected void AppendIndented(string text)
        {
            AppendIndendation();
            Output.Append(text);
        }

        protected void AppendIndentedLine(string line)
        {
            AppendIndendation();
            Output.AppendLine(line);
        }

        protected void AppendIndendation()
        {
            Output.Append(' ', BaseIndentation);
        }

        public override string ToString()
        {
            return Output.ToString();
        }
    }

    public class InterfaceOutputAppender : DocumentedOutputAppender<TypeScriptInterface>
    {
        private bool InGlobalModule { get; set; }

        public InterfaceOutputAppender(StringBuilder output, int baseIndentation, Settings settings, bool inGlobalModule)
            : base(output, baseIndentation, settings)
        {
            this.InGlobalModule = inGlobalModule;
        }

        public override void AppendOutput(TypeScriptInterface tsInterface)
        {
            foreach (var tsSubEnum in tsInterface.SubEnums)
            {
                AppendOutputSubEnum(tsSubEnum, tsInterface);
            }

            foreach (var tsSubClass in tsInterface.SubClasses)
            {
                AppendOutputSubClass(tsSubClass, tsInterface);
            }

            BeginInterface(tsInterface);

            AppendMembers(tsInterface);
            
            if (tsInterface.IndexedType != null)
                AppendIndexer(tsInterface);

            EndInterface();
        }
        private void AppendOutputSubClass(TypeScriptInterface tsInterface, TypeScriptInterface owner)
        {
            BeginInterface(tsInterface, owner);

            foreach (var tsSubClass in tsInterface.SubClasses)
            {
                AppendOutput(tsSubClass);
            }

            AppendMembers(tsInterface, owner);

            if (tsInterface.IndexedType != null)
                AppendIndexer(tsInterface);

            EndInterface(owner);
        }
        
        private void AppendOutputSubEnum(TypeScriptEnum tsEnum, TypeScriptInterface owner)
        {
            var enumAppender = new EnumOutputAppender(Output, BaseIndentation, Settings);
            enumAppender.AppendOutputSubEnum(tsEnum, owner);
        }

        private void AppendMembers(TypeScriptInterface tsInterface, TypeScriptInterface owner = null)
        {
            var identation = 4;
            while (owner != null)
            {
                identation += 4;
                owner = owner.Owner;
            }
            var appender = new MemberOutputAppender(Output, BaseIndentation + identation, Settings);
            foreach (var member in tsInterface.Members)
                appender.AppendOutput(member);
        }

        private void BeginInterface(TypeScriptInterface tsInterface, TypeScriptInterface owner = null)
        {
            AppendIndentedLine("/** Generated from " + tsInterface.FullName + " **/");
            AppendDocumentation(tsInterface);

            if (owner == null)
            {
                if (InGlobalModule)
                    AppendIndented("interface " + tsInterface.Name);
                else
                    AppendIndented("export interface " + tsInterface.Name);
            }
            else
            {
                var module = owner.Name;
                var interfaceName = tsInterface.Name;
                var arr = tsInterface.Name.Split('.');
                if (arr.Length > 1)
                {
                    module = arr[0];
                    interfaceName = arr[1];
                }
                AppendIndentedLine("export module " + module + " {");
                AppendIndendation();
                AppendIndented("export interface " + interfaceName);
            }

            if (tsInterface.Parent != null)
                Output.Append(" extends " + (tsInterface.Parent.Module.IsGlobal ? "" : tsInterface.Parent.Module.QualifiedName + ".") + tsInterface.Parent.Name);

            Output.AppendLine(" {");
        }

        private void EndInterface(TypeScriptInterface owner = null)
        {
            while (owner != null)
            {
                AppendIndendation();
                AppendIndentedLine("}");
                owner = owner.Owner;
            }
            AppendIndentedLine("}");
        }

        private void AppendIndexer(TypeScriptInterface tsInterface)
        {
            AppendIndendation();
            Output.AppendFormat("    [index: number]: {0};", tsInterface.IndexedType);
            Output.AppendLine();
        }
    }

    public class MemberOutputAppender : DocumentedOutputAppender<TypeScriptInterfaceMember>
    {
        public MemberOutputAppender(StringBuilder output, int baseIndentation, Settings settings)
            : base(output, baseIndentation, settings)
        {
        }

        public override void AppendOutput(TypeScriptInterfaceMember member)
        {
            AppendDocumentation(member);
            AppendIndendation();

            var isOptional = member.Optional || (member.Type is NullableType);
            var type = member.Type.ToString();

            if (member.Type is BoolType)
            {
                if (Settings.CompatibilityVersion != null && Settings.CompatibilityVersion < new Version(0, 9, 0))
                    type = "bool";
                else
                    type = "boolean";
            }
            Output.AppendFormat("{0}{1}: {2}",
                member.Name,
                (isOptional ? "?" : ""),
                type
            );
            
            Output.AppendLine(";");
        }
    }

    public class ModuleOutputAppender : OutputAppender<TypeScriptModule>
    {
        public ModuleOutputAppender(StringBuilder output, int baseIndentation, Settings settings)
            : base(output, baseIndentation, settings)
        {
        }

        public override void AppendOutput(TypeScriptModule module)
        {
            BeginModule(module);

            var enumAppender = new EnumOutputAppender(Output, BaseIndentation + 4, Settings);
            foreach (var tsEnum in module.Enums)
                enumAppender.AppendOutput(tsEnum);

            var interfaceAppender = new InterfaceOutputAppender(Output, BaseIndentation + 4, Settings, module.IsGlobal);
            foreach (var tsInterface in module.Interfaces)
                interfaceAppender.AppendOutput(tsInterface);

            EndModule(module);
        }

        private void BeginModule(TypeScriptModule module)
        {
            if (module.IsGlobal)
            {
                Output.AppendLine("// -- Begin global interfaces");
            }
            else
            {
                if (Settings.CompatibilityVersion != null && Settings.CompatibilityVersion < new Version(0, 9, 0))
                    Output.Append("module ");
                else
                    Output.Append("declare module ");

                Output.Append(module.QualifiedName);
                Output.AppendLine(" {");
            }
        }

        private void EndModule(TypeScriptModule module)
        {
            if (module.IsGlobal)
                Output.AppendLine("// -- End global interfaces");
            else
                Output.AppendLine("}");
        }
    }

    public static class OutputFormatter
    {
        public static string GetOutput(List<TypeScriptModule> modules, Settings settings)
        {
            var output = new StringBuilder();
            
            output.AppendLine("/****************************************************************************");
            output.AppendLine("  Generated by T4TS.tt - don't make any changes in this file");
            output.AppendLine("****************************************************************************/");

            var moduleAppender = new ModuleOutputAppender(output, 0, settings);
            foreach (var module in modules)
            {
                output.AppendLine();
                moduleAppender.AppendOutput(module);
            }

            return output.ToString();
        }
    }

    public class TypeScriptEnum : IDocumentedElement
    {
        public string Name { get; set; }
        public string FullName { get; set; }

        public List<TypeScriptEnumMember> Members { get; set; }
        public TypeScriptModule Module { get; set; }
        public TypeScriptInterface Owner { get; set; }

        public string Comment { get; set; }
        public string DocComment { get; set; }

        public TypeScriptEnum()
        {
            Members = new List<TypeScriptEnumMember>();
        }
    }

    public class TypeScriptEnumAttributeValues
    {
        public string Module { get; set; }
        public string Name { get; set; }
        public string NamePrefix { get; set; }
    }

    public class TypeScriptInterfaceAttributeValues
    {
        public string Module { get; set; }
        public string Name { get; set; }
        public string NamePrefix { get; set; }
    }

    public class TypeScriptEnumMember : IDocumentedElement
    {
        public string Name { get; set; }
        public string FullName { get; set; }
        public int Value { get; set; }
        public bool Ignore { get; set; }
        public string Comment { get; set; }
        public string DocComment { get; set; }
    }

    public class TypeScriptMemberAttributeValues
    {
        public string Name { get; set; }
        public bool Optional { get; set; }
        public string Type { get; set; }
        public bool CamelCase { get; set; }
        public bool Ignore { get; set; }
    }

    public class CodeTraverser
    {
        public Solution Solution { get; private set; }
        public static Settings Settings { get; private set; }

        private const string InterfaceAttributeFullName = "T4TS.TypeScriptInterfaceAttribute";
        private const string MemberAttributeFullName = "T4TS.TypeScriptMemberAttribute";
        private const string EnumAttributeFullName = "T4TS.TypeScriptEnumAttribute";

        public CodeTraverser(Solution solution, Settings settings)
        {
            if (solution == null)
                throw new ArgumentNullException("solution");

            if (settings == null)
                throw new ArgumentNullException("settings");

            Solution = solution;
            Settings = settings;
        }


        private void BuildCodeClass(TypeContext typeContext, CodeClass codeClass, CodeClass owner = null, bool forcedProcessing = false)
        {
            if (codeClass == null) return;
            CodeAttribute attribute;
            InterfaceType interfaceType = null;
            if (owner != null)
            {
                var tsType = typeContext.GetTypeScriptType(owner.FullName);
                if (tsType != null)
                    interfaceType = new InterfaceType(codeClass.Name);
            }
            if (forcedProcessing)
            {
                var values = new TypeScriptInterfaceAttributeValues
                {
                    Name = codeClass.Name,
                    Module = Settings.DefaultModule ?? "T4TS",
                    NamePrefix = Settings.DefaultInterfaceNamePrefix ?? string.Empty
                };
                interfaceType = new InterfaceType(values);
            }

            if (TryGetAttribute(codeClass.Attributes, InterfaceAttributeFullName, out attribute))
            {
                var values = GetInterfaceValues(codeClass, attribute);
                interfaceType = new InterfaceType(values);
            }
            else if (Settings.ProcessDataContracts && TryGetAttribute(codeClass.Attributes, "System.Runtime.Serialization.DataContractAttribute", out attribute))
            {
                var values = new TypeScriptInterfaceAttributeValues
                {
                    Name = codeClass.Name,
                    Module = Settings.DefaultModule ?? "T4TS",
                    NamePrefix = Settings.DefaultInterfaceNamePrefix ?? string.Empty
                };
                interfaceType = new InterfaceType(values);
            }
            if (interfaceType != null)
            {
                // Process parent classes anyway if it has not TypeScriptAttribute or DataContractAttribute
                if (Settings.ProcessParentClasses)
                {
                    CodeClass parentClass = null;
                    if (codeClass.Bases.Count > 0)
                        parentClass = codeClass.Bases.Item(1) as CodeClass;
                    if (parentClass != null && parentClass.FullName != "System.Object")
                    {
                        BuildCodeClass(typeContext, parentClass, null, true);
                    }
                }

                if (!typeContext.ContainsInterfaceType(codeClass.FullName))
                    typeContext.AddInterfaceType(codeClass.FullName, interfaceType);

                foreach (var subCodeElement in codeClass.Members)
                {
                    var subCodeClass = subCodeElement as CodeClass;
                    if (subCodeClass != null && subCodeClass.Access == vsCMAccess.vsCMAccessPublic)
                        BuildCodeClass(typeContext, subCodeClass, codeClass);
                    var subCodeEnum = subCodeElement as CodeEnum;
                    if (subCodeEnum != null && subCodeEnum.Access == vsCMAccess.vsCMAccessPublic)
                        BuildCodeEnum(typeContext, subCodeEnum, codeClass);
                }
            }
        }
        private void BuildCodeEnum(TypeContext typeContext, CodeEnum codeEnum, CodeClass owner = null)
        {
            if (codeEnum == null) return;
            CodeAttribute attribute;
            EnumType enumType = null;
            if (owner != null)
            {
                var tsType = typeContext.GetTypeScriptType(owner.FullName);
                if (tsType != null)
                    enumType = new EnumType(codeEnum.Name);
            }
            if (TryGetAttribute(codeEnum.Attributes, EnumAttributeFullName, out attribute))
            {
                var values = GetEnumValues(codeEnum, attribute);
                enumType = new EnumType(values);
            }
            if (enumType != null)
            {
                if (!typeContext.ContainsEnumType(codeEnum.FullName))
                    typeContext.AddEnumType(codeEnum.FullName, enumType);
            }
        }

        public TypeContext BuildContext()
        {
            var typeContext = new TypeContext(Settings);

            new SolutionTraverser(Solution, ns => 
            {
                new NamespaceTraverser(ns,
                    codeClass => BuildCodeClass(typeContext, codeClass),
                    codeEnum => BuildCodeEnum(typeContext, codeEnum)
                );
            });

            return typeContext;
        }

        private void ProcessCodeClass(TypeContext typeContext, IDictionary<CodeClass, TypeScriptInterface> tsMap, 
            IDictionary<string, TypeScriptModule> byModuleName, CodeClass codeClass)
        {
            InterfaceType interfaceType;
            if (typeContext.TryGetInterfaceType(codeClass.FullName, out interfaceType))
            {
                var values = interfaceType.AttributeValues;

                TypeScriptModule module;
                if (!byModuleName.TryGetValue(values.Module, out module))
                {
                    module = new TypeScriptModule { QualifiedName = values.Module };
                    byModuleName.Add(values.Module, module);
                }

                var tsInterface = BuildInterface(codeClass, values, typeContext);
                tsMap.Add(codeClass, tsInterface);
                tsInterface.Module = module;
                module.Interfaces.Add(tsInterface);
            }
        }

        private void ProcessCodeEnum(TypeContext typeContext, IDictionary<CodeEnum, TypeScriptEnum> tsEnumMap,
            IDictionary<string, TypeScriptModule> byModuleName, CodeEnum codeEnum)
        {
            EnumType enumType;
            if (typeContext.TryGetEnumType(codeEnum.FullName, out enumType))
            {
                var values = enumType.AttributeValues;

                TypeScriptModule module;
                if (!byModuleName.TryGetValue(values.Module, out module))
                {
                    module = new TypeScriptModule { QualifiedName = values.Module };
                    byModuleName.Add(values.Module, module);
                }

                var tsEnum = BuildEnum(codeEnum, values, typeContext);
                tsEnumMap.Add(codeEnum, tsEnum);
                tsEnum.Module = module;
                module.Enums.Add(tsEnum);
            }
        }

        public IEnumerable<TypeScriptModule> GetAllInterfaces()
        {
            var typeContext = BuildContext();
            var byModuleName = new Dictionary<string, TypeScriptModule>();
            var tsMap = new Dictionary<CodeClass, TypeScriptInterface>();
            var tsEnumMap = new Dictionary<CodeEnum, TypeScriptEnum>();

            new SolutionTraverser(Solution, ns =>
            {
                new NamespaceTraverser(ns, 
                    codeClass => ProcessCodeClass(typeContext, tsMap, byModuleName, codeClass),
                    codeEnum => ProcessCodeEnum(typeContext, tsEnumMap, byModuleName, codeEnum)
                );
            });

            var tsInterfaces = tsMap.Values.ToList();
            tsMap.Keys.ToList().ForEach(codeClass =>
            {
                var baseClasses = codeClass.Bases;
                if (baseClasses != null && baseClasses.Count > 0)
                {
                    var baseClass = baseClasses.Item(1);
                    if (baseClass != null)
                    {
                        // We must remove all text after < char, to compare generic types.
                        // It's not really correct, but must work in common cases.
                        var baseClassNonGenericFullName = baseClass.FullName.Split('<')[0];
                        TypeScriptInterface parent = tsInterfaces.SingleOrDefault(intf => baseClassNonGenericFullName == intf.FullName.Split('<')[0]);
                        if (parent != null)
                        {
                            tsMap[codeClass].Parent = parent;
                        }
                    }
                }
            });

            return byModuleName.Values
                .OrderBy(m => m.QualifiedName)
                .ToList();
        }
        
        private string GetInterfaceName(TypeScriptInterfaceAttributeValues attributeValues)
        {
            if (!string.IsNullOrEmpty(attributeValues.NamePrefix))
                return attributeValues.NamePrefix + attributeValues.Name;

            return attributeValues.Name;
        }
        private string GetEnumName(TypeScriptEnumAttributeValues attributeValues)
        {
            if (!string.IsNullOrEmpty(attributeValues.NamePrefix))
                return attributeValues.NamePrefix + attributeValues.Name;

            return attributeValues.Name;
        }

        private TypeScriptInterface BuildInterface(CodeClass codeClass, TypeScriptInterfaceAttributeValues attributeValues, TypeContext typeContext)
        {
            var tsInterface = new TypeScriptInterface
            {
                FullName = codeClass.FullName,
                Name = GetInterfaceName(attributeValues),
                Comment = codeClass.Comment,
                DocComment = codeClass.DocComment
            };

            // Add sub-classes to the interface
            foreach (var codeSubClass in codeClass.Members.OfType<CodeClass>().Where(cc => cc.Access == vsCMAccess.vsCMAccessPublic))
            {
                var subAttributeValues = new TypeScriptInterfaceAttributeValues { Name = codeSubClass.Name };
                InterfaceType interfaceType;
                if (typeContext.TryGetInterfaceType(codeSubClass.FullName, out interfaceType))
                {
                    subAttributeValues = interfaceType.AttributeValues;
                    subAttributeValues.Module = attributeValues.Module + "." + tsInterface.Name;
                }
                    
                var subInterface = BuildInterface(codeSubClass, subAttributeValues, typeContext);
                subInterface.Owner = tsInterface;
                tsInterface.SubClasses.Add(subInterface);
            }

            // Add sub-enums to the interface
            foreach (CodeEnum codeSubEnum in codeClass.Members.OfType<CodeEnum>().Where(cc => cc.Access == vsCMAccess.vsCMAccessPublic))
            {
                var subAttributeValues = new TypeScriptEnumAttributeValues { Name = codeSubEnum.Name };
                EnumType enumType;
                if (typeContext.TryGetEnumType(codeSubEnum.FullName, out enumType))
                {
                    subAttributeValues = enumType.AttributeValues;
                    subAttributeValues.Module = attributeValues.Module + "." + tsInterface.Name;
                }
                    
                var subEnum = BuildEnum(codeSubEnum, subAttributeValues, typeContext);
                subEnum.Owner = tsInterface;
                tsInterface.SubEnums.Add(subEnum);
            }

            TypescriptType indexedType;
            if (TryGetIndexedType(codeClass, typeContext, out indexedType))
                tsInterface.IndexedType = indexedType;

            new ClassTraverser(codeClass, property =>
            {
                TypeScriptInterfaceMember member;
                if (TryGetMember(property, typeContext, out member))
                    tsInterface.Members.Add(member);
            });


            return tsInterface;
        }
        private TypeScriptEnum BuildEnum(CodeEnum codeEnum, TypeScriptEnumAttributeValues attributeValues, TypeContext typeContext)
        {
            var tsEnum = new TypeScriptEnum
            {
                FullName = codeEnum.FullName,
                Name = GetEnumName(attributeValues),
                Comment = codeEnum.Comment,
                DocComment = codeEnum.DocComment
            };

            new EnumTraverser(codeEnum, (variable, index) =>
            {
                TypeScriptEnumMember member;
                if (TryGetEnumMember(variable, typeContext, index, out member))
                    tsEnum.Members.Add(member);
            });

            return tsEnum;
        }

        private bool TryGetAttribute(CodeElements attributes, string attributeFullName, out CodeAttribute attribute, bool useShortAttributeName = false)
        {
            foreach (CodeAttribute attr in attributes)
            {
                var attrName = attr.FullName ?? "";
                if (useShortAttributeName)
                    attrName = attrName.Split('.').Last().Split('+').Last();
                if (attrName == attributeFullName)
                {
                    attribute = attr;
                    return true;
                }
            }

            attribute = null;
            return false;
        }

        private bool TryGetIndexedType(CodeClass codeClass, TypeContext typeContext, out TypescriptType indexedType)
        {
            indexedType = null;
            if (codeClass.Bases == null || codeClass.Bases.Count == 0)
                return false;

            foreach (CodeElement baseClass in codeClass.Bases)
            {
                if (TypeContext.IsGenericEnumerable(baseClass.FullName))
                {
                    string fullName = typeContext.UnwrapGenericType(baseClass.FullName);
                    indexedType = typeContext.GetTypeScriptType(fullName);
                    return true;
                }
            }

            return false;
        }

        private TypeScriptInterfaceAttributeValues GetInterfaceValues(CodeClass codeClass, CodeAttribute interfaceAttribute)
        {
            var values = GetAttributeValues(interfaceAttribute);

            return new TypeScriptInterfaceAttributeValues
            {
                Name = values.ContainsKey("Name") ? values["Name"] : codeClass.Name,
                Module = values.ContainsKey("Module") ? values["Module"] : Settings.DefaultModule ?? "T4TS",
                NamePrefix = values.ContainsKey("NamePrefix") ? values["NamePrefix"] : Settings.DefaultInterfaceNamePrefix ?? string.Empty
            };
        }
        private TypeScriptEnumAttributeValues GetEnumValues(CodeEnum codeEnum, CodeAttribute interfaceAttribute)
        {
            var values = GetAttributeValues(interfaceAttribute);

            return new TypeScriptEnumAttributeValues
            {
                Name = values.ContainsKey("Name") ? values["Name"] : codeEnum.Name,
                Module = values.ContainsKey("Module") ? values["Module"] : Settings.DefaultModule ?? "T4TS",
                NamePrefix = values.ContainsKey("NamePrefix") ? values["NamePrefix"] : Settings.DefaultEnumNamePrefix ?? string.Empty
            };
        }

        private bool TryGetMember(CodeProperty property, TypeContext typeContext, out TypeScriptInterfaceMember member)
        {
            member = null;

            var getter = property.Getter;
            if (getter == null || property.Name == "this")
                return false;

            var values = GetMemberValues(property, typeContext);

            string name;
            if (values.Name != null)
            {
                name = values.Name;
            }
            else
            {
                name = property.Name;
                if (name.StartsWith("@"))
                    name = name.Substring(1);
            }

            member = new TypeScriptInterfaceMember
            {
                Name = name,
                //FullName = property.FullName,
                Optional = values.Optional,
                Ignore = values.Ignore,
                Type = (string.IsNullOrWhiteSpace(values.Type))
                    ? typeContext.GetTypeScriptType(getter.Type)
                    : new InterfaceType(values.Type),
                Comment = property.Comment,
                DocComment = property.DocComment
            };

            if (member.Name == null)
            {
                // The property is not explicit marked with TypeScriptMemberAttribute
                if (property.Access != vsCMAccess.vsCMAccessPublic)
                    // remove non-public default properties
                    return false;
                member.Name = property.Name;
            }

            if (member.Ignore)
                return false;

            if (values.CamelCase && values.Name == null)
                member.Name = member.Name.Substring(0, 1).ToLowerInvariant() + member.Name.Substring(1);

            return true;
        }

        private bool TryGetEnumMember(CodeVariable variable, TypeContext typeContext, int index, out TypeScriptEnumMember member)
        {
            var values = GetMemberValues(variable, typeContext);
            member = new TypeScriptEnumMember
            {
                Name = values.Name,
                FullName = variable.FullName,
                Ignore = values.Ignore,
                Value = variable.InitExpression == null ? index : Int32.Parse(variable.InitExpression.ToString()),
                Comment = variable.Comment,
                DocComment = variable.DocComment
            };

            if (member.Name == null)
            {
                // The property is not explicit marked with TypeScriptMemberAttribute
                if (variable.Access != vsCMAccess.vsCMAccessPublic)
                    // remove non-public default properties
                    return false;
                member.Name = variable.Name;
            }

            if (member.Ignore)
            {
                return false;
            }

            if (values.CamelCase && values.Name == null)
                member.Name = member.Name.Substring(0, 1).ToLowerInvariant() + member.Name.Substring(1);

            return true;
        }

        private TypeScriptMemberAttributeValues GetMemberValues(CodeProperty property, TypeContext typeContext)
        {
            bool? attributeOptional = null;
            bool? attributeCamelCase = null;
            bool attributeIgnore = false;
            string attributeName = null;
            string attributeType = null;

            CodeAttribute attribute;

            // By default ignore properties marked with MemberIgnoreAttributes
            if (Settings.MemberIgnoreAttributes.Any(a => TryGetAttribute(property.Attributes, a, out attribute, true)))
            {
                attributeIgnore = true;
            }

            if (TryGetAttribute(property.Attributes, MemberAttributeFullName, out attribute))
            {
                var values = GetAttributeValues(attribute);
                bool parsedProperty;
                if (values.ContainsKey("Optional") && bool.TryParse(values["Optional"], out parsedProperty))
                    attributeOptional = parsedProperty;

                if (values.ContainsKey("CamelCase") && bool.TryParse(values["CamelCase"], out parsedProperty))
                    attributeCamelCase = parsedProperty;

                if (values.ContainsKey("Ignore") && bool.TryParse(values["Ignore"], out parsedProperty))
                    attributeIgnore = parsedProperty;

                values.TryGetValue("Name", out attributeName);
                values.TryGetValue("Type", out attributeType);
            }

            return new TypeScriptMemberAttributeValues
            {
                Optional = attributeOptional.HasValue ? attributeOptional.Value : Settings.DefaultOptional,
                Name = attributeName,
                Type = attributeType,
                CamelCase = attributeCamelCase ?? Settings.DefaultCamelCaseMemberNames,
                Ignore = attributeIgnore
            };
        }

        private TypeScriptMemberAttributeValues GetMemberValues(CodeVariable variable, TypeContext typeContext)
        {
            bool? attributeOptional = null;
            bool? attributeCamelCase = null;
            bool attributeIgnore = false;
            string attributeName = null;
            string attributeType = null;

            CodeAttribute attribute;

            // By default ignore properties marked with MemberIgnoreAttributes
            if (Settings.MemberIgnoreAttributes.Any(a => TryGetAttribute(variable.Attributes, a, out attribute, true)))
            {
                attributeIgnore = true;
            }

            if (TryGetAttribute(variable.Attributes, MemberAttributeFullName, out attribute))
            {
                var values = GetAttributeValues(attribute);
                if (values.ContainsKey("Optional"))
                    attributeOptional = values["Optional"] == "true";

                if (values.ContainsKey("CamelCase"))
                    attributeCamelCase = values["CamelCase"] == "true";

                if (values.ContainsKey("Ignore"))
                    attributeIgnore = values["Ignore"] == "true";

                values.TryGetValue("Name", out attributeName);
                values.TryGetValue("Type", out attributeType);
            }

            return new TypeScriptMemberAttributeValues
            {
                Optional = attributeOptional.HasValue ? attributeOptional.Value : Settings.DefaultOptional,
                Name = attributeName,
                Type = attributeType,
                CamelCase = attributeCamelCase ?? Settings.DefaultCamelCaseMemberNames,
                Ignore = attributeIgnore
            };
        }

        private Dictionary<string, string> GetAttributeValues(CodeAttribute codeAttribute)
        {
            var values = new Dictionary<string, string>();
            foreach (CodeElement child in codeAttribute.Children)
            {
                var property = (EnvDTE80.CodeAttributeArgument)child;
                if (property == null || property.Value == null)
                    continue;
                
                // remove quotes if the property is a string
                string val = property.Value ?? string.Empty;
                if (val.StartsWith("\"") && val.EndsWith("\""))
                    val = val.Substring(1, val.Length - 2);

                values.Add(property.Name, val);
            }

            return values;
        }
    }

    public class Settings
    {
        /// <summary>
        /// The default module of the generated interface, if not specified by the TypeScriptInterfaceAttribute
        /// </summary>
        public string DefaultModule { get; set; }

        /// <summary>
        /// The default value for Optional, if not specified by the TypeScriptMemberAttribute
        /// </summary>
        public bool DefaultOptional { get; set; }

        /// <summary>
        /// The default value for the CamelCase flag for an interface member name, if not specified by the TypeScriptMemberAttribute
        /// </summary>
        public bool DefaultCamelCaseMemberNames { get; set; }

        /// <summary>
        /// The default string to prefix interface names with. For instance, you might want to prefix the names with an "I" to get conventional interface names.
        /// </summary>
        public string DefaultInterfaceNamePrefix { get; set; }

        /// <summary>
        /// The default string to prefix enum names with. For instance, you might want to prefix the names with an "E" to get conventional enum names.
        /// </summary>
        public string DefaultEnumNamePrefix { get; set; }

        /// <summary>
        /// The version of Typescript that is targeted
        /// </summary>
        public Version CompatibilityVersion { get; set; }

        /// <summary>
        /// If true translates System.DateTime to native date
        /// </summary>
        public bool UseNativeDates { get; set; }


        /// <summary>
        /// List of the project names to process. If null - all the projects will be processed.
        /// </summary>
        public string[] ProjectNamesToProcess { get; set; }

        /// <summary>
        ///     If equals <c>true</c> - classes marked with <see cref="DataContractAttribute"/> will be processed.
        /// </summary>
        public bool ProcessDataContracts { get; set; }

        /// <summary>
        ///     If equals <c>true</c> - parent classes will be processed even if they weren't marked with <see cref="TypeScriptInterfaceAttribute"/> or <see cref="DataContractAttribute"/>.
        /// </summary>
        public bool ProcessParentClasses { get; set; }

        /// <summary>
        ///     Additional list of the additional attribute short names which prevents processing of the members. 
        ///     If null - the properties marked with <see cref="JsonIgnoreAttribute"/> will be ignored.
        /// </summary>
        public string[] MemberIgnoreAttributes { get; set; }


        /// <summary>
        ///     If equals <c>true</c> - static properties will be processed. (Not implemented yet).
        /// </summary>
        public bool IncludeStatics { get; set; }

        
        public Settings()
        {
            DefaultModule = "T4TS";
            MemberIgnoreAttributes = new[] {"JsonIgnoreAttribute"};
        }


        public static Settings Parse(Dictionary<string, object> settingsValues)
        {
            // Read settings from T4TS.tt.settings.tt
            return new Settings
            {
                DefaultModule = ParseSettingReferenceType(settingsValues, "DefaultModule", s => s as string, "T4TS"),
                DefaultOptional = ParseSettingNullableType(settingsValues, "DefaultOptional", false),
                DefaultCamelCaseMemberNames = ParseSettingNullableType(settingsValues, "DefaultCamelCaseMemberNames", false),
                DefaultInterfaceNamePrefix = ParseSettingReferenceType(settingsValues, "DefaultInterfaceNamePrefix", s => s as string, string.Empty),
                CompatibilityVersion = ParseSettingReferenceType(settingsValues, "CompatibilityVersion", v => v as Version, new Version(0, 9, 1, 1)),
                UseNativeDates = ParseSettingNullableType(settingsValues, "UseNativeDates", false),
                ProjectNamesToProcess = ParseSettingReferenceType(settingsValues, "ProjectNamesToProcess", s => s == null ? null : s.ToString().Replace(" ", "").Split(','), null),
                ProcessParentClasses = ParseSettingNullableType(settingsValues, "ProcessParentClasses", false),
                MemberIgnoreAttributes = ParseSettingReferenceType(settingsValues, "MemberIgnoreAttributes", s => s as string, "JsonIgnoreAttribute").Split(','),
                IncludeStatics = ParseSettingNullableType(settingsValues, "IncludeStatics", false),
            };
        }

        private static T ParseSettingReferenceType<T>(Dictionary<string, object> settingsValues, string key, Func<object, T> convert, T defaultValue) where T : class
        {
            object val;
            if (settingsValues.TryGetValue(key, out val))
                return convert(val) ?? defaultValue;

            return defaultValue;
        }

        private static T ParseSettingNullableType<T>(Dictionary<string, object> settingsValues, string key, T defaultValue) where T : struct
        {
            object val;
            if (settingsValues.TryGetValue(key, out val))
            {
                return (val as T?) ?? defaultValue;
            }

            return defaultValue;
        }

        private static T ParseConfigValueType<T>(Dictionary<string, object> settingsValues, string key, Func<object, T> convert, T defaultValue)
        {
            object val;
            if (settingsValues.TryGetValue(key, out val))
                return convert(val);

            return defaultValue;
        }

    }

    public class EnumTraverser
    {
        public CodeEnum CodeEnum { get; private set; }
        public Action<CodeVariable, int> WithVariable { get; set; }

        public EnumTraverser(CodeEnum codeEnum, Action<CodeVariable, int> withVariable)
        {
            if (codeEnum == null) throw new ArgumentNullException("codeEnum");

            if (withVariable == null) throw new ArgumentNullException("withVariable");

            CodeEnum = codeEnum;
            WithVariable = withVariable;

            if (codeEnum.Members != null)
                Traverse(codeEnum.Members);
        }

        private void Traverse(CodeElements members)
        {
            var index = 0;
            foreach (var property in members.OfType<CodeVariable>())
            {
                WithVariable(property, index);
                if (property.InitExpression != null)
                    index = Int32.Parse(property.InitExpression.ToString());
                index++;
            }
                
        }
    }

    public class ClassTraverser
    {
        public CodeClass CodeClass { get; private set; }
        public Action<CodeProperty> WithProperty { get; private set; }

        public ClassTraverser(CodeClass codeClass, Action<CodeProperty> withProperty)
        {
            if (codeClass == null) throw new ArgumentNullException("codeClass");
            if (withProperty == null) throw new ArgumentNullException("withProperty");

            CodeClass = codeClass;
            WithProperty = withProperty;

            if (codeClass.Members != null)
                Traverse(codeClass.Members);
        }

        private void Traverse(CodeElements members)
        {
            foreach (var property in members)
            {
                if (property is CodeProperty)
                    WithProperty((CodeProperty)property);
            }
        }
    }

    public class NamespaceTraverser
    {
        public Action<CodeClass> WithCodeClass { get; private set; }
        public Action<CodeEnum> WithCodeEnum { get; private set; }

        public NamespaceTraverser(CodeNamespace ns, Action<CodeClass> withCodeClass, Action<CodeEnum> withCodeEnum)
        {
            if (ns == null)
                throw new ArgumentNullException("ns");
            
            if (withCodeClass == null)
                throw new ArgumentNullException("withCodeClass");
            
            WithCodeClass = withCodeClass;

            WithCodeEnum = withCodeEnum;
            
            if (ns.Members != null)
                Traverse(ns.Members);
        }

        private void Traverse(CodeElements members)
        {
            foreach (object elem in members)
            {
                if (elem is CodeEnum)
                    WithCodeEnum((CodeEnum)elem);
                if (elem is CodeClass)
                    WithCodeClass((CodeClass)elem);
            }
        }
    }

    public class ProjectTraverser
    {
        static readonly Guid SolutionItemKind = Guid.Parse(Constants.vsProjectKindSolutionItems);

        public Action<CodeNamespace> WithNamespace { get; private set; }

        public ProjectTraverser(Project project, Action<CodeNamespace> withNamespace)
        {
            if (project == null)
                throw new ArgumentNullException("project");
            
            if (withNamespace == null)
                throw new ArgumentNullException("withNamespace");

            WithNamespace = withNamespace;

            TraverseProject(project);
        }

        private void TraverseProject(Project project)
        {
            if (project.ProjectItems != null)
            {
                // traverse projects inside solution items
                if (Guid.Parse(project.Kind) == SolutionItemKind)
                {
                    foreach (ProjectItem pi in project.ProjectItems)
                    {
                        if (pi.SubProject != null)
                            TraverseProject(pi.SubProject);
                    }
                }

                // normal projects
                else if (CodeTraverser.Settings.ProjectNamesToProcess == null ||
                         CodeTraverser.Settings.ProjectNamesToProcess.Contains(project.Name))
                {
                    Traverse(project.ProjectItems);
                }
            }
        }

        private void Traverse(ProjectItems items)
        {
            foreach (ProjectItem pi in items)
            {
                if (ShouldProcessItem(pi))
                {
                    if (pi.FileCodeModel != null)
                    {
                        var codeElements = pi.FileCodeModel.CodeElements;

                        foreach (object elem in codeElements)
                        {
                            if (elem is CodeNamespace)
                                WithNamespace((CodeNamespace)elem);
                        }
                    }
                }

                if (pi.ProjectItems != null)
                    Traverse(pi.ProjectItems);
            }
        }

        private bool ShouldProcessItem(ProjectItem pi)
        {
            var fileName = pi.FileNames[0];

            if (System.IO.Path.GetExtension(fileName) == ".cs")
            {
                //support for unit tests
                if (fileName == "sourcefile.cs")
                    return true;

                var content = System.IO.File.ReadAllText(fileName);
                if (content.Contains("TypeScript"))
                    return true;
            }

            return false;
        }
    }

    public class TypeScriptModule
    {
        public string QualifiedName { get; set; }
        public List<TypeScriptInterface> Interfaces { get; set; }
        public List<TypeScriptEnum> Enums { get; set; }

        /// <summary>
        /// Returns true if this is the global namespace (ie. no module name)
        /// </summary>
        public bool IsGlobal
        {
            get { return string.IsNullOrWhiteSpace(QualifiedName); }
        }

        public TypeScriptModule()
        {
            Interfaces = new List<TypeScriptInterface>();
            Enums = new List<TypeScriptEnum>();
        }
    }

    public class SolutionTraverser
    {
        public Action<CodeNamespace> WithNamespace { get; private set; }

        public SolutionTraverser(Solution solution, Action<CodeNamespace> withNamespace)
        {
            if (solution == null)
                throw new ArgumentNullException("solution");

            if (withNamespace == null)
                throw new ArgumentNullException("withNamespace");

            WithNamespace = withNamespace;

            if (solution.Projects != null)
                Traverse(solution.Projects);
        }

        private void Traverse(Projects projects)
        {
            foreach (Project project in projects)
            {
                new ProjectTraverser(project, WithNamespace);
            }
        }
    }

    public class TypeFullName
    {
        public string FullName { get; private set; }
        public TypeFullName[] TypeArgumentFullNames { get; private set; }

        public TypeFullName(string name, params TypeFullName[] arguments)
        {
            this.FullName = name;
            this.TypeArgumentFullNames = arguments;
        }

        public bool IsEnumerable()
        {
            return this.FullName == "System.Collections.Generic.IEnumerable";
        }

        public bool IsDictionary()
        {
            switch(this.FullName)
            {
                case "System.Collections.Generic.Dictionary":
                case "System.Collections.Generic.IDictionary":
                    return true;

                default:
                    return false;
            }
        }

        public static TypeFullName FromString(string name)
        {
            return TypeFullNameParser.Parse(name);
        }

        public override bool Equals(object obj)
        {
            if (obj == this)
                return true;

            if (obj == null)
                return false;

            if (obj is TypeFullName)
                return obj.ToString() == this.ToString();
            
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            int hashCode = 17;

            if (this.TypeArgumentFullNames != null)
                hashCode = (hashCode * 23) + this.TypeArgumentFullNames.GetHashCode();

            if (this.FullName != null)
                hashCode = (hashCode * 29) + this.FullName.GetHashCode();

            return hashCode;
        }

        public override string ToString()
        {
            if (TypeArgumentFullNames == null || TypeArgumentFullNames.Length == 0)
                return FullName;

            string nameWithGenerics = FullName + "<";
            foreach (var arg in TypeArgumentFullNames)
                nameWithGenerics += arg.ToString() + ",";
            
            if (nameWithGenerics.EndsWith(","))
                nameWithGenerics = nameWithGenerics.Substring(0, nameWithGenerics.Length - 1);
            
            return nameWithGenerics + ">";
        }
    }

    class TypeFullNameParser
    {
        private static TypeFullName ParseCSharp(string fullNameFromType)
        {
            string fullName = fullNameFromType.Substring(0, fullNameFromType.IndexOf("<"));
            string restPart = fullNameFromType.Substring(fullNameFromType.IndexOf("<"));

            int openBraceCount = 0;
            int count = 0;

            var typeArguments = new List<TypeFullName>();
            var chars = new List<char>();

            foreach (var c in restPart)
            {
                if ((c != '<' && c != '>' && c != ',') || openBraceCount > 1)
                {
                    chars.Add(c);
                }

                if (c == ',' && openBraceCount == 1)
                {
                    typeArguments.Add(Parse(new String(chars.ToArray()).Trim()));
                    chars.Clear();
                }

                if (c == '<')
                {
                    openBraceCount++;
                }
                else if (c == '>')
                {
                    openBraceCount--;

                    if (openBraceCount == 0)
                    {
                        typeArguments.Add(Parse(new String(chars.ToArray()).Trim()));
                        chars.Clear();
                    }
                }

                count++;
            }

            return new TypeFullName(fullName, typeArguments.ToArray());
        }

        public static TypeFullName Parse(string fullNameFromType)
        {
            if (fullNameFromType.Contains("<"))
                return ParseCSharp(fullNameFromType);

            if (!fullNameFromType.Contains("`"))
            {
                if (fullNameFromType.Contains(","))
                    return Parse(fullNameFromType.Substring(0, fullNameFromType.IndexOf(",")));

                return new TypeFullName(fullNameFromType);
            }

            string fullName = fullNameFromType.Substring(0, fullNameFromType.IndexOf("`"));
            string restPart = fullNameFromType.Substring(fullNameFromType.IndexOf("[") + 1);

            restPart = restPart.Substring(0, restPart.Length - 1);

            int openBraceCount = 0;
            int count = 0;

            var typeArguments = new List<TypeFullName>();
            var chars = new List<char>();

            foreach (var c in restPart)
            {
                if ((c != '[' && c != ']') || openBraceCount > 1)
                {
                    if (c != ',' || openBraceCount != 0)
                        chars.Add(c);
                }

                if (c == '[')
                {
                    openBraceCount++;
                }
                else if (c == ']')
                {
                    openBraceCount--;

                    if (openBraceCount == 0)
                    {
                        typeArguments.Add(Parse(new String(chars.ToArray())));
                        chars.Clear();
                    }
                }

                count++;
            }

            return new TypeFullName(fullName, typeArguments.ToArray());
        }
    }

    public class ArrayType: TypescriptType
    {
        public TypescriptType ElementType { get; set; }

        public override string ToString()
        {
            return ElementType.ToString() + "[]";
        }
    }

    public class BoolType: TypescriptType
    {
        public override string Name
        {
            get { return "boolean"; }
        }
    }

    public class DictionaryType : TypescriptType
    {
        public TypescriptType KeyType { get; set; }
        public TypescriptType ElementType { get; set; }

        public override string ToString()
        {
            return "{ [name: NameType]: ValueType}".Replace("NameType", KeyType.ToString()).Replace("ValueType", ElementType.ToString());
        }
    }

    public class EnumType : TypescriptType
    {
        public TypeScriptEnumAttributeValues AttributeValues { get; private set; }

        public string QualifedModule 
        { 
            get 
            {
                if (AttributeValues == null)
                    return null;

                return AttributeValues.Module; 
            } 
        }

        public override string Name
        {
            get
            {
                if (!string.IsNullOrEmpty(AttributeValues.NamePrefix))
                    return AttributeValues.NamePrefix + AttributeValues.Name;

                return AttributeValues.Name;
            }
        }

        public EnumType(TypeScriptEnumAttributeValues values)
        {
            AttributeValues = values;
        }

        public EnumType(string name)
        {
            AttributeValues = new TypeScriptEnumAttributeValues
            {
                Name = name
            };
        }

        public override string ToString()
        {
            if (string.IsNullOrWhiteSpace(QualifedModule))
                return base.ToString();

            return QualifedModule + "." + base.ToString();
        }
    }

    public class InterfaceType : TypescriptType
    {
        public TypeScriptInterfaceAttributeValues AttributeValues { get; private set; }

        public string QualifedModule 
        { 
            get 
            {
                if (AttributeValues == null)
                    return null;

                return AttributeValues.Module; 
            } 
        }

        public override string Name
        {
            get
            {
                if (!string.IsNullOrEmpty(AttributeValues.NamePrefix))
                    return AttributeValues.NamePrefix + AttributeValues.Name;

                return AttributeValues.Name;
            }
        }

        public InterfaceType(TypeScriptInterfaceAttributeValues values)
        {
            AttributeValues = values;
        }

        public InterfaceType(string name)
        {
            AttributeValues = new TypeScriptInterfaceAttributeValues
            {
                Name = name
            };
        }

        public override string ToString()
        {
            if (string.IsNullOrWhiteSpace(QualifedModule))
                return base.ToString();

            return QualifedModule + "." + base.ToString();
        }
    }

    public class NullableType : TypescriptType
    {
        public TypescriptType WrappedType { get; set; }

        public override string ToString()
        {
            return WrappedType.ToString();
        }
    }

    public class NumberType : TypescriptType
    {
        public override string Name
        {
            get { return "number"; }
        }
    }

    public class DateTimeType : TypescriptType
    {
        public override string Name
        {
            get { return "Date"; }
        }
    }

    public class StringType: TypescriptType
    {
        public override string Name
        {
            get { return "string"; }
        }
    }

    public class TypeContext
    {
        public Settings Settings { get; private set; }
        public TypeContext(Settings settings)
        {
            Settings = settings;
        }

        private static readonly string[] _genericCollectionTypeStarts =
        {
            "System.Collections.Generic.List<",
            "System.Collections.Generic.IList<",
            "System.Collections.Generic.ICollection<",
            "System.Collections.Generic.IEnumerable<"
        };

        private const string NullableTypeStart = "System.Nullable<";

        /// <summary>
        /// Lookup table for "interface types", ie. non-builtin types (typically classes or unknown types). Keyed on the FullName of the type.
        /// </summary>
        private readonly Dictionary<string, InterfaceType> _interfaceTypes = new Dictionary<string, InterfaceType>();

        private readonly Dictionary<string, EnumType> _enumTypes = new Dictionary<string, EnumType>();

        public void AddInterfaceType(string typeFullName, InterfaceType interfaceType)
        {
            _interfaceTypes.Add(typeFullName, interfaceType);
        }
        public void AddEnumType(string typeFullName, EnumType enumType)
        {
            _enumTypes.Add(typeFullName, enumType);
        }

        public bool TryGetInterfaceType(string typeFullName, out InterfaceType interfaceType)
        {
            return _interfaceTypes.TryGetValue(typeFullName, out interfaceType);
        }

        public bool TryGetEnumType(string typeFullName, out EnumType enumType)
        {
            return _enumTypes.TryGetValue(typeFullName, out enumType);
        }

        public bool ContainsInterfaceType(string typeFullName)
        {
            return _interfaceTypes.ContainsKey(typeFullName);
        }
        public bool ContainsEnumType(string typeFullName)
        {
            return _enumTypes.ContainsKey(typeFullName);
        }

        public TypescriptType GetTypeScriptType(CodeTypeRef codeType)
        {
            switch (codeType.TypeKind)
            {
                case vsCMTypeRef.vsCMTypeRefChar:
                case vsCMTypeRef.vsCMTypeRefString:
                    return new StringType();

                case vsCMTypeRef.vsCMTypeRefBool:
                    return new BoolType();

                case vsCMTypeRef.vsCMTypeRefByte:
                case vsCMTypeRef.vsCMTypeRefDouble:
                case vsCMTypeRef.vsCMTypeRefInt:
                case vsCMTypeRef.vsCMTypeRefShort:
                case vsCMTypeRef.vsCMTypeRefFloat:
                case vsCMTypeRef.vsCMTypeRefLong:
                case vsCMTypeRef.vsCMTypeRefDecimal:
                    return new NumberType();

                default:
                    return TryResolveType(codeType);
            }
        }

        private TypescriptType TryResolveType(CodeTypeRef codeType)
        {
            if (codeType.TypeKind == vsCMTypeRef.vsCMTypeRefArray)
            {
                return new ArrayType
                {
                    ElementType = GetTypeScriptType(codeType.ElementType)
                };
            }
            

            return GetTypeScriptType(codeType.AsFullName);
        }

        public TypescriptType GetTypeScriptType(string typeFullName)
        {
            InterfaceType interfaceType;
            if (_interfaceTypes.TryGetValue(typeFullName, out interfaceType))
                return interfaceType;

            EnumType enumType;
            if (_enumTypes.TryGetValue(typeFullName, out enumType))
                return enumType;

            if (IsGenericEnumerable(typeFullName))
            {
                return new ArrayType
                {
                    ElementType = GetTypeScriptType(UnwrapGenericType(typeFullName))
                };
            }
            else if (IsNullable(typeFullName))
            {
                return new NullableType
                {
                    WrappedType = GetTypeScriptType(UnwrapGenericType(typeFullName))
                };
            }

            var realType = TypeFullNameParser.Parse(typeFullName);

            if (realType.IsEnumerable())
            {
                return new ArrayType()
                {
                    ElementType = GetTypeScriptType(realType.TypeArgumentFullNames[0].FullName)
                };
            }
            else if(realType.IsDictionary())
            {
                return new DictionaryType()
                {
                    KeyType = GetTypeScriptType(realType.TypeArgumentFullNames[0].FullName),
                    ElementType = GetTypeScriptType(realType.TypeArgumentFullNames[1].FullName)
                };
            }

            switch (typeFullName)
            {
                case "System.Guid":
                    return new GuidType();
                case "System.Boolean":
                    return new BoolType();
                case "System.Double":
                case "System.Int16":
                case "System.Int32":
                case "System.Int64":
                case "System.UInt16":
                case "System.UInt32":
                case "System.UInt64":
                case "System.Decimal":
                case "System.Byte":
                case "System.SByte":
                case "System.Single":
                    return new NumberType();

                case "System.String":
                    return new StringType();

                case "System.DateTime":
                case "System.DateTimeOffset":
                    if (Settings.UseNativeDates)
                        return new DateTimeType();
                    else
                        return new StringType();

                default:
                    return new TypescriptType();
            }
        }

        private bool IsNullable(string typeFullName)
        {
            return typeFullName.StartsWith(NullableTypeStart);
        }

        public string UnwrapGenericType(string typeFullName)
        {
            int firstIndex = typeFullName.IndexOf('<');
            return typeFullName.Substring(firstIndex+1, typeFullName.Length - firstIndex- 2);
        }

        public static bool IsGenericEnumerable(string typeFullName)
        {
            return _genericCollectionTypeStarts.Any(typeFullName.StartsWith);
        }
    }

    public class TypeScriptInterface : IDocumentedElement
    {
        public string Name { get; set; }
        public string FullName { get; set; }
        
        public string Comment { get; set; }
        public string DocComment { get; set; }
        public List<TypeScriptInterfaceMember> Members { get; set; }
        public TypescriptType IndexedType { get; set; }
        public TypeScriptInterface Parent { get; set; }
        public TypeScriptModule Module { get; set; }
        public TypeScriptInterface Owner { get; set; }


        public List<TypeScriptInterface> SubClasses { get; set; }
        public List<TypeScriptEnum> SubEnums { get; set; }

        public TypeScriptInterface()
        {
            Members = new List<TypeScriptInterfaceMember>();
            SubClasses = new List<TypeScriptInterface>();
            SubEnums = new List<TypeScriptEnum>();
        }
    }

    public class TypeScriptInterfaceMember : IDocumentedElement
    {
        public string Name { get; set; }

        public string Comment { get; set; }
        public string DocComment { get; set; }
        public TypescriptType Type { get; set; }
        public bool Optional { get; set; }
        public bool Ignore { get; set; }
    }

    public class GuidType : TypescriptType
    {
        public override string Name
        {
            get { return "string"; }
        }
    }

    public class TypescriptType
    {
        public virtual string Name { get { return "any"; } }

        public override string ToString()
        {
            return Name;
        }
    }

#>